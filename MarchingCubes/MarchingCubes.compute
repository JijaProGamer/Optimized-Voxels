#include "MarchingTable.hlsl"
#pragma kernel March;

struct Triangle {
    float3 a, b, c;
    uint exists;
};

StructuredBuffer<int2> Chunks;
StructuredBuffer<float> Densities;
RWStructuredBuffer<Triangle> Result;

float3 interp(float3 edgeVertex1, float valueAtVertex1, float3 edgeVertex2, float valueAtVertex2)
{
    return float3(0,0,1);
    //return (edgeVertex1 + (0.5 - valueAtVertex1) * (edgeVertex2 - edgeVertex1)  / (valueAtVertex2 - valueAtVertex1));
}

uint indexFromId(uint group, uint3 id){
    return group * 512 + (id.x + 8 * (id.y + 8 * id.z));
}

[numthreads(8,8,8)]
void March (uint3 group_id: SV_GroupID, uint3 individual_id: SV_GroupThreadID)
{
    uint index = indexFromId(group_id.x, individual_id) * 5;

    float cubeValues[8] = {
       Densities[indexFromId(group_id, uint3(individual_id.x, individual_id.y, individual_id.z + 1))],
       Densities[indexFromId(group_id, uint3(individual_id.x + 1, individual_id.y, individual_id.z + 1))],
       Densities[indexFromId(group_id, uint3(individual_id.x + 1, individual_id.y, individual_id.z))],
       Densities[indexFromId(group_id, uint3(individual_id.x, individual_id.y, individual_id.z))],
       Densities[indexFromId(group_id, uint3(individual_id.x, individual_id.y + 1, individual_id.z + 1))],
       Densities[indexFromId(group_id, uint3(individual_id.x + 1, individual_id.y + 1, individual_id.z + 1))],
       Densities[indexFromId(group_id, uint3(individual_id.x + 1, individual_id.y + 1, individual_id.z))],
       Densities[indexFromId(group_id, uint3(individual_id.x, individual_id.y + 1, individual_id.z))]
    };

    int cubeIndex = 0;
    if (cubeValues[0] < 0.5) cubeIndex |= 1;
    if (cubeValues[1] < 0.5) cubeIndex |= 2;
    if (cubeValues[2] < 0.5) cubeIndex |= 4;
    if (cubeValues[3] < 0.5) cubeIndex |= 8;
    if (cubeValues[4] < 0.5) cubeIndex |= 16;
    if (cubeValues[5] < 0.5) cubeIndex |= 32;
    if (cubeValues[6] < 0.5) cubeIndex |= 64;
    if (cubeValues[7] < 0.5) cubeIndex |= 128;

    int edges[] = triTable[cubeIndex];
    for (uint i = 0; edges[i] != -1; i += 3)
    {
        int e00 = edgeConnections[edges[i]][0];
        int e01 = edgeConnections[edges[i]][1];

        int e10 = edgeConnections[edges[i + 1]][0];
        int e11 = edgeConnections[edges[i + 1]][1];
        
        int e20 = edgeConnections[edges[i + 2]][0];
        int e21 = edgeConnections[edges[i + 2]][1];

        Triangle tri;
        tri.exists = 1;

        tri.a = interp(cornerOffsets[e00], cubeValues[e00], cornerOffsets[e01], cubeValues[e01]) + individual_id;
        tri.b = interp(cornerOffsets[e10], cubeValues[e10], cornerOffsets[e11], cubeValues[e11]) + individual_id;
        tri.c = interp(cornerOffsets[e20], cubeValues[e20], cornerOffsets[e21], cubeValues[e21]) + individual_id;

        Result[index + i / 3] = tri;
    }
}