#pragma kernel D2Build
#pragma kernel D3Build
#include "FastNoiseLite.hlsl"

struct voxelResult {
    float density;
    int color_r, color_g, color_b;
};

StructuredBuffer<int3> positions;

RWStructuredBuffer<float> Result2D;
RWStructuredBuffer<voxelResult> Result3D;

int seed;
int amplitude;
int octaves;
float frequency;

uint idToIndex2D(uint3 id, uint group_id){
    return group_id * 64 + (id.x + 8 * id.z);
}

uint idToIndex3D(uint3 id, uint group_id){
    return group_id * 512 + (id.x + 8 * (id.y + 8 * id.z));
}

[numthreads(8,1,8)]
void D2Build (uint3 id: SV_GroupThreadID, uint3 group_id: SV_GroupID)
{
    int3 Chunk = positions[group_id.x];
    int x = Chunk.x * 8 + id.x;
    int z = Chunk.z * 8 + id.z;

    fnl_state noiseState = fnlCreateState();
    noiseState.noise_type = FNL_NOISE_OPENSIMPLEX2;
    noiseState.seed = seed;

    float noise = ((fnlGetNoise2D(noiseState, x, z) + 1) / 2) * amplitude;

    //Result2D[idToIndex2D(id, group_id.x)] = id.x + id.z;
    Result2D[idToIndex2D(id, group_id.x)] = noise;
}

[numthreads(8,8,8)]
void D3Build (uint3 id: SV_GroupThreadID, uint3 group_id: SV_GroupID)
{
    int3 Chunk = positions[group_id.x];
    int x = Chunk.x * 8 + id.x;
    int y = Chunk.y * 8 + id.y;
    int z = Chunk.z * 8 + id.z;

    voxelResult result;

    result.color_r = 15;
    result.color_g = 28;
    result.color_b = 99;

    fnl_state noiseState = fnlCreateState();
    noiseState.noise_type = FNL_NOISE_OPENSIMPLEX2;
    noiseState.seed = seed;

    result.density = (fnlGetNoise3D(noiseState, x, y, z) + 1) / 2;

    Result3D[idToIndex3D(id, group_id.x)] = result;
}